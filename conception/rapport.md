# Rapport Conception Malware

## Tests anti-debug
Nous avons commencé l'exécution du programme par un test anti-debug. Nous n'en avons pas mis beaucoup puisqu'ils sont relativement faciles à contourner.
Nous aurions aimés cependant en rajouter et en dissimuler plus.

Nous vérifions juste les retours des fonctions IsDebuggerPresent(), CheckRemoteDebuggerPresent(), et l'usage du PEB.

## strings chiffrés
Premièrement, nous avons chiffré la plupart des chaînes de caractères utilisées.
Celles-ci sont déchiffrées à la volée et le résultat est stocké dans un flux temporaire (en temps normal aucun texte n'est affiché pendant l'exécution)

## fonctions chiffrées
Nous avons également embarqué des fonctions que nous avons chiffrées.
Celles-ci sont également déchiffrées à la volée et brouillées après utilisation.

Pour générer le code à embarquer, nous avons rédigé ces fonctions dans un fichier source,
que nous avons compilé en fichier objet (avec cl.exe), puis nous les avons extraites avec dumpbin.exe.
Il nous a suffit ensuite de copier leur code binaire et de l'importer dans le code source final.

Les fonctions embarquées peuvent utiliser d'autres fonctions, mais qui pourraient avoir été compilées à un autre endroit que lors de la génération du code embarqué. Nous passons donc l'adresse des fonctions utilisées en tant qu'argument des fonctions embarquées.

Les fonctions de génération de clé et de comparaison de clé ont été embarquées et chiffrées.
La fonction permettant de cacher l'usage de xor, elle, a été embarquée mais non chiffrée. Ce, pour pouvoir modifier le code binaire et y cacher le xor.

## appel dynamique des fonctions
Quasimment tous les appels de fonctions sont cachés lors de l'exécution du programme.
On utilise un pointeur dont l'adresse de la fonction pointée est calculée à l'exécution.

## génération de la clé
Pour générer la clé, nous avons donc chiffrée la fonction (cf. fonctions chiffrées).
L'appel à cette fonction chiffrée est également caché (cf. appel dynamique).

La génération de la clé est faite par génération de nombres pseudo aléatoires, à partir d'une graine fixe (0xdeadbeef).

## Dissimulation du xor

Puisque le chiffrement est très utilisé pour les chaîne de caractères et des fonctions, nous avons dissimulé l'usage du xor.

Pour ce faire, nous avons caché l'opérande xor dans une opérande plus grande, nous faisons ensuite un saut à l'adresse de l'opérande xor, ce qui la dissimule un peu.

## attente d'une minute avant d'afficher quoique ce soit

Enfin, comme dit plus haut, en temps normal rien n'est affiché sur la console pendant l'exécution. A la fin du programme, celui-ci attendant jusqu'à qu'il ait été exécuté depuis un peu moins d'une minute, puis affiche toutes les chaines de caractères qui ont été mises en attente depuis.

## Ajout de faux flags
Nous avons rajouté quelques chaînes de caractères inutiles par example "00deadbeef",
nous avons également rajouté une fausse clé, qui est bien comparé avec l'entré et qui provoque l'affichage d'un message particulier.

## techniques prévues mais non appliquées faute de temps:
- vérifier l'intégrité du code
- ajouter des contre-mesures plus efficaces contre le debug etc.
- ajouter plus de test anti-debug/les cacher mieux
- à l'origine nous avions pensé cacher la clé dans une image resource de l'exécutable, mais cela n'a pas été faisable.

## exécution
malware.exe <a-f0-9>

## clé: a1182c3a235f33cdb11efc9ef85e3e1cf73387266293c87f4467147ce9e3a500
il n'y a qu'une seule clé.
