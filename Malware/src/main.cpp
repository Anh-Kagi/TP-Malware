#include "stdafx/stdafx.h"

#include <iostream>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <ctime>

#include <Windows.h>

#include "debugger/debugger.h"
#include "embedded/embedded.h"
#include "embedded/generated.h"
#include "parser/hex.h"
#include "parser/strtob.h"
#include "strings/strings.h"

using namespace std;

void print_key(ostream& out, const unsigned char* key) {
	for (int i=0; i<32; i++)
		out << hex << setw(2) << setfill('0') << (unsigned int) key[i];
}

void print_obfstr(ostream& out, const char* str, size_t len, char key) {
	for (unsigned int i=0; i<len; i++)
		out << (char) (str[i] ^ key);
}

// TODO:
// - fonction integrité check
// - hash ?
// - check Thread Local Storage (possibilité d'exécuter du code avant le main)
// - disperser les debugger check (+ tenter de se débugger soi-même pr embêter un potentiel débuggeur)
// - contre-mesures (si mdp mauvais, debugger ou jsp)
// - cacher les xors
// - cacher des instruction assembleur en faisant des jump au milieu (on skip le premier octet) d'une instruction (sera affiché différemment au désassemblage)

int main(int argc, char* argv[])
{
#ifndef _DEBUG
	time_t end_time = time(nullptr) + 59;
#endif
	ostringstream sout;

	char* fn = (char*) &main;
	fn += (char*) &isDbg - (char*) &main;
	if (((is_dbg_t) fn)()) {
		print_obfstr(cerr, stop_dbg, stop_dbg_len, KEY3);
		cerr << endl;
		return -1;
	}

	if (argc < 2) {
		print_obfstr(cerr, no_arg, no_arg_len, KEY3);
		cerr << endl;
		return -2;
	}

	fn += (char*) &isHex - (char*) &isDbg;
	if (strlen(argv[1]) > 64 || !((is_hex_t) fn)(argv[1])) {
		print_obfstr(cerr, no_hex, no_hex_len, KEY3);
		cerr << endl;
		return -3;
	}

	fn += (char*) &strtobytes - (char*) isHex;
	unsigned char* input_key = ((strtobytes_t) fn)(argv[1]);
	sout << "input: ";
	print_key(sout, input_key);
	sout << endl << "argv[1]: " << argv[1] << endl;
	
	fn += (char*) &generate_key - (char*) &strtobytes;
	unsigned char* key = new unsigned char[32];
	unsigned char ctr;
	for (unsigned int i=0; i<generate_key_len; i++) fn[i] ^= KEY1;
	((generate_key_t) fn)(&srand, &rand, &memset, &memcpy, key, &ctr);
	for (unsigned int i=0; i<generate_key_len; i++) fn[i] = (char) rand();

	for (unsigned int i=0; i<key_str_len; i++) sout << (char) (key_str[i] ^ KEY3);
	print_key(sout, key);
	sout << endl;

	fn += (char*) &key_cmp - (char*) &generate_key;
	char fake_flag[] = {
		'\xff', '\x7c', '\xef', '\x69',
		'\xa1', '\x8a', '\x0c', '\x83',
		'\x66', '\x1c', '\x2c', '\x30',
		'\x77', '\xc9', '\x76', '\x87',
		'\x1f', '\x3a', '\x59', '\x7a',
		'\x24', '\xe5', '\x44', '\x66',
		'\x31', '\x95', '\x5f', '\xf4',
		'\x0b', '\x4a', '\x1a', '\x7e',
		'\x08', '\xeb', '\xa3', '\x0e',
		'\xc3', '\x42', '\x44', '\x5d',
		'\xca', '\x7a', '\x16', '\x1d',
		'\xc9', '\x08', '\x48', '\x5f',
		'\x6c', '\xc2', '\x54', '\x80',
		'\x96', '\xb9', '\x2e', '\x2e',
		'\x05', '\x06', '\x9c', '\x8c',
		'\x9e', '\x4b', '\xef', '\x67',
	};
	for (unsigned int i=0; i<key_cmp_len; i++) fn[i] ^= KEY2;
	if (((key_cmp_t) fn)(&memcmp, key, input_key)) {
		for (unsigned int i=0; i<good_input_len; i++) sout << (char) (good_input[i] ^ KEY3);
		print_obfstr(sout, troll, troll_len, KEY3);
		sout << endl << "00deadbeef00" << endl;
		print_key(sout, (unsigned char*) fake_flag);
	} else if (!memcmp(input_key, fake_flag, 32)) {
		print_obfstr(sout, fake_flag_str, fake_flag_str_len, KEY3);
	} else {
		for (unsigned int i=0; i<wrong_input_len; i++) sout << (char) (wrong_input[i] ^ KEY3);
	}
	sout << endl;
	for (unsigned int i=0; i<key_cmp_len; i++) fn[i] = (char) rand();
	delete[] input_key;

#ifndef _DEBUG
	Sleep((DWORD) (end_time-time(nullptr)) * 1000); // wait until a minute passes away
#endif

	cout << sout.str();

	return 0;
}
