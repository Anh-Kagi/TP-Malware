#include "stdafx/stdafx.h"

#include <iostream>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <ctime>

#include <Windows.h>

#include "debugger/debugger.h"
#include "embedded/embedded.h"
#include "embedded/generated.h"
#include "parser/hex.h"
#include "parser/strtob.h"
#include "strings/strings.h"

using namespace std;

char xor[] = { // char xor(const char a, const char b)
	'\x55', // push ebp
	'\x89', '\xE5', // mov ebp, esp
	'\x0F', '\xBE', '\x45', '\x08', // movsx eax, byte ptr [ebp + 8]
	'\x0F', '\xBE', '\x4D', '\x0C', // movsx ecx, byte ptr [ebp + 0xc]
	'\x39', '\xDB', // cmp ebx, ebx
	'\x74', '\x01', // jmp to xor (ignore le 0x3d)
	'\x3D', '\x31', '\xC8', // [cmp] xor eax, ecx
	'\x5D', // pop ebp
	'\xC3', // ret
};
typedef char (*xor_t)(const char a, const char b);

void uncipher(char* code, const size_t code_len, const char key) {
	for (size_t i=0; i<code_len; i++)
		code[i] = ((xor_t) &xor)(code[i], key);
}

void clear(char* code, const size_t code_len) {
	for (size_t i=0; i<code_len; i++)
		code[i] = (char) rand();
}

void print_key(ostream& out, const unsigned char* key) {
	for (size_t i=0; i<32; i++)
		out << hex << setw(2) << setfill('0') << (unsigned int) key[i];
}

void print_obfstr(ostream& out, const char* str, const size_t len, char key) {
	for (size_t i=0; i<len; i++)
		out << ((xor_t) &xor)((char) str[i], key);
}


#ifdef _DEBUG
void wait_until(time_t) {}
#else
void wait_until(time_t end_time) {
	Sleep((DWORD) (end_time-time(nullptr)) * 1000);
}
#endif

// TODO:
// - fonction integrité check
// - disperser les debugger check (+ tenter de se débugger soi-même pr embêter un potentiel débuggeur)
// - contre-mesures (si mdp mauvais, debugger ou jsp)

int main(int argc, char* argv[])
{
	time_t end_time = time(nullptr) + 59;
	ostringstream sout;

	if (argc < 2) {
		print_obfstr(cerr, no_arg, no_arg_len, KEY3);
		cerr << endl;
		return -2;
	}

	char* fn = (char*) &main;
	fn += (char*) &isHex - (char*) &main;
	if (strlen(argv[1]) > 64 || !((is_hex_t) fn)(argv[1])) {
		print_obfstr(cerr, no_hex, no_hex_len, KEY3);
		cerr << endl;
		return -3;
	}

	fn += (char*) &strtobytes - (char*) &isHex;
	unsigned char* input_key = ((strtobytes_t) fn)(argv[1]);
	sout << "input: ";
	print_key(sout, input_key);
	sout << endl << "argv[1]: " << argv[1] << endl;

	fn += (char*) &isDbg - (char*) &strtobytes;
	if (((is_dbg_t) fn)()) {
		wait_until(end_time);
		cout << sout.str();
		print_obfstr(cerr, stop_dbg, stop_dbg_len, KEY3);
		cerr << endl;
		return -1;
	}
	
	fn += (char*) &generate_key - (char*) &isDbg;
	unsigned char* key = new unsigned char[32];
	unsigned char ctr;
	uncipher(fn, generate_key_len, KEY1);
	((generate_key_t) fn)(&srand, &rand, &memset, &memcpy, key, &ctr);
	clear(fn, generate_key_len);

#ifdef _DEBUG
	sout << key_str;
	print_key(sout, key);
	sout << endl;
#endif

	fn += (char*) &key_cmp - (char*) &generate_key;
	char fake_flag[] = {
		'\xff', '\x7c', '\xef', '\x69',
		'\xa1', '\x8a', '\x0c', '\x83',
		'\x66', '\x1c', '\x2c', '\x30',
		'\x77', '\xc9', '\x76', '\x87',
		'\x1f', '\x3a', '\x59', '\x7a',
		'\x24', '\xe5', '\x44', '\x66',
		'\x31', '\x95', '\x5f', '\xf4',
		'\x0b', '\x4a', '\x1a', '\x7e',
		'\x08', '\xeb', '\xa3', '\x0e',
		'\xc3', '\x42', '\x44', '\x5d',
		'\xca', '\x7a', '\x16', '\x1d',
		'\xc9', '\x08', '\x48', '\x5f',
		'\x6c', '\xc2', '\x54', '\x80',
		'\x96', '\xb9', '\x2e', '\x2e',
		'\x05', '\x06', '\x9c', '\x8c',
		'\x9e', '\x4b', '\xef', '\x67',
	};
	uncipher(fn, key_cmp_len, KEY2);
	if (((key_cmp_t) fn)(&memcmp, key, input_key)) {
		print_obfstr(sout, good_input, good_input_len, KEY3);
		sout << endl << endl;
		print_obfstr(sout, troll, troll_len, KEY3);
		sout << endl << "00deadbeef00" << endl;
		print_key(sout, (unsigned char*) fake_flag);
	} else if (!memcmp(input_key, fake_flag, 32)) {
		print_obfstr(sout, fake_flag_str, fake_flag_str_len, KEY3);
	} else {
		print_obfstr(sout, wrong_input, wrong_input_len, KEY3);
	}
	sout << endl;
	clear(fn, key_cmp_len);
	delete[] input_key;

	wait_until(end_time);
	cout << sout.str();

	return 0;
}
