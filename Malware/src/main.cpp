#include "stdafx/stdafx.h"

#include <iostream>
#include <iomanip>
#include <cstring>

#include <Windows.h>

#include "debugger/debugger.h"
#include "embedded/embedded.h"
#include "parser/hex.h"
#include "parser/strtob.h"
#include "strings/strings.h"

using namespace std;

void print_key(ostream& out, const unsigned char* key) {
	for (int i=0; i<32; i++) out << hex << setw(2) << setfill('0') << (unsigned int) key[i];
}

#define KEY1 0x42
char generate_key[] = {
	'\x53' ^ KEY1,
	'\x55' ^ KEY1,
	'\x56' ^ KEY1,
	'\x57' ^ KEY1,
	'\x68' ^ KEY1, '\xef' ^ KEY1, '\xbe' ^ KEY1, '\xad' ^ KEY1, '\xde' ^ KEY1,
	'\xff' ^ KEY1, '\x54' ^ KEY1, '\x24' ^ KEY1, '\x18' ^ KEY1,
	'\x8b' ^ KEY1, '\x7c' ^ KEY1, '\x24' ^ KEY1, '\x28' ^ KEY1,
	'\x6a' ^ KEY1, '\x20' ^ KEY1,
	'\x6a' ^ KEY1, '\x00' ^ KEY1,
	'\x57' ^ KEY1,
	'\xff' ^ KEY1, '\x54' ^ KEY1, '\x24' ^ KEY1, '\x2c' ^ KEY1,
	'\x8b' ^ KEY1, '\x5c' ^ KEY1, '\x24' ^ KEY1, '\x30' ^ KEY1,
	'\x8b' ^ KEY1, '\x6C' ^ KEY1, '\x24' ^ KEY1, '\x28' ^ KEY1,
	'\x83' ^ KEY1, '\xc4' ^ KEY1, '\x10' ^ KEY1,
	'\x33' ^ KEY1, '\xf6' ^ KEY1,
	'\xff' ^ KEY1, '\xd5' ^ KEY1,
	'\x89' ^ KEY1, '\x44' ^ KEY1, '\x24' ^ KEY1, '\x14' ^ KEY1,
	'\x6a' ^ KEY1, '\x01' ^ KEY1,
	'\x8d' ^ KEY1, '\x44' ^ KEY1, '\x24' ^ KEY1, '\x18' ^ KEY1,
	'\x50' ^ KEY1,
	'\x8d' ^ KEY1, '\x0c' ^ KEY1, '\x3e' ^ KEY1,
	'\x51' ^ KEY1,
	'\xff' ^ KEY1, '\xd3' ^ KEY1,
	'\x46' ^ KEY1,
	'\x83' ^ KEY1, '\xc4' ^ KEY1, '\x0c' ^ KEY1,
	'\x83' ^ KEY1, '\xfe' ^ KEY1, '\x20' ^ KEY1,
	'\x7c' ^ KEY1, '\xe4' ^ KEY1,
	'\x5f' ^ KEY1,
	'\x5e' ^ KEY1,
	'\x5d' ^ KEY1,
	'\x5b' ^ KEY1,
	'\xc3' ^ KEY1,
};

#define KEY2 0x27
char key_cmp[] = {
	'\x8b' ^ KEY2, '\x44' ^ KEY2, '\x24' ^ KEY2, '\x0c' ^ KEY2,
	'\x8b' ^ KEY2, '\x4c' ^ KEY2, '\x24' ^ KEY2, '\x08' ^ KEY2,
	'\x6a' ^ KEY2, '\x20' ^ KEY2,
	'\x50' ^ KEY2,
	'\x51' ^ KEY2,
	'\xff' ^ KEY2, '\x54' ^ KEY2, '\x24' ^ KEY2, '\x10' ^ KEY2,
	'\x83' ^ KEY2, '\xc4' ^ KEY2, '\x0c' ^ KEY2,
	'\xf7' ^ KEY2, '\xd8' ^ KEY2,
	'\x1b' ^ KEY2, '\xc0' ^ KEY2,
	'\x40' ^ KEY2,
	'\xc3' ^ KEY2,
};

// TODO:
// - fonction integrité check
// - faux flags
// - obfuscations chaîne de caractères lambda
// - timer pour durer exactement 1min

int main(int argc, char* argv[])
{
	char* fn = (char*) &main;
	fn += (char*) &isDbg - (char*) &main;
	if (((is_dbg_t) fn)()) {
		for (unsigned int i=0; i<stop_dbg_len; i++) cerr << (char) (stop_dbg[i] ^ KEY3);
		cerr << endl;
		return -1;
	}

	if (argc < 2) {
		for (unsigned int i=0; i<no_arg_len; i++) cerr << (char) (no_arg[i] ^ KEY3);
		cerr << endl;
		return -2;
	}

	fn += (char*) &isHex - (char*) &isDbg;
	if (strlen(argv[1]) > 64 || !((is_hex_t) fn)(argv[1])) {
		for (unsigned int i=0; i<no_hex_len; i++) cerr << (char) (no_hex[i] ^ KEY3);
		cerr << endl;
		return -3;
	}

	fn += (char*) &strtobytes - (char*) isHex;
	unsigned char* input_key = ((strtobytes_t) fn)(argv[1]);
	cout << "input: ";
	print_key(cout, input_key);
	cout << endl << "argv[1]: " << argv[1] << endl;
	
	fn += (char*) &generate_key - (char*) &strtobytes;
	unsigned char* key = new unsigned char[32];
	unsigned char ctr;
	for (int i=0; i<sizeof(generate_key); i++) fn[i] ^= KEY1;
	((generate_key_t) fn)(&srand, &rand, &memset, &memcpy, key, &ctr);
	for (int i=0; i<sizeof(generate_key); i++) fn[i] = (char) rand();

	for (unsigned int i=0; i<key_str_len; i++) cout << (char) (key_str[i] ^ KEY3);
	print_key(cout, key);
	cout << endl;

	fn += (char*) &key_cmp - (char*) &generate_key;
	for (int i=0; i<sizeof(key_cmp); i++) fn[i] ^= KEY2;
	if (((key_cmp_t) fn)(&memcmp, key, input_key)) {
		for (unsigned int i=0; i<good_input_len; i++) cout << (char) (good_input[i] ^ KEY3);
		cout << endl;
	} else {
		for (unsigned int i=0; i<wrong_input_len; i++) cerr << (char) (wrong_input[i] ^ KEY3);
		cerr << endl;
	}
	for (int i=0; i<sizeof(key_cmp); i++) fn[i] = (char) rand();
	delete[] input_key;

	return 0;
}
