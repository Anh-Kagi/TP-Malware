#include "stdafx/stdafx.h"

#include <iostream>
#include <iomanip>
#include <sstream>
#include <cstring>
#include <ctime>

#include <Windows.h>

#include "debugger/debugger.h"
#include "embedded/embedded.h"
#include "embedded/generated.h"
#include "parser/hex.h"
#include "parser/strtob.h"
#include "strings/strings.h"

using namespace std;

void print_key(ostream& out, const unsigned char* key) {
	for (int i=0; i<32; i++)
		out << hex << setw(2) << setfill('0') << (unsigned int) key[i];
}

void print_obfstr(ostream& out, const char* str, size_t len, char key) {
	for (unsigned int i=0; i<len; i++)
		out << (char) (str[i] ^ key);
}

// TODO:
// - fonction integrité check
// - faux flags
// - hash ?

int main(int argc, char* argv[])
{
#ifndef _DEBUG
	time_t end_time = time(nullptr) + 59;
#endif
	ostringstream sout;

	char* fn = (char*) &main;
	fn += (char*) &isDbg - (char*) &main;
	if (((is_dbg_t) fn)()) {
		print_obfstr(cerr, stop_dbg, stop_dbg_len, KEY3);
		cerr << endl;
		return -1;
	}

	if (argc < 2) {
		print_obfstr(cerr, no_arg, no_arg_len, KEY3);
		cerr << endl;
		return -2;
	}

	fn += (char*) &isHex - (char*) &isDbg;
	if (strlen(argv[1]) > 64 || !((is_hex_t) fn)(argv[1])) {
		print_obfstr(cerr, no_hex, no_hex_len, KEY3);
		cerr << endl;
		return -3;
	}

	fn += (char*) &strtobytes - (char*) isHex;
	unsigned char* input_key = ((strtobytes_t) fn)(argv[1]);
	sout << "input: ";
	print_key(sout, input_key);
	sout << endl << "argv[1]: " << argv[1] << endl;
	
	fn += (char*) &generate_key - (char*) &strtobytes;
	unsigned char* key = new unsigned char[32];
	unsigned char ctr;
	for (unsigned int i=0; i<generate_key_len; i++) fn[i] ^= KEY1;
	((generate_key_t) fn)(&srand, &rand, &memset, &memcpy, key, &ctr);
	for (unsigned int i=0; i<generate_key_len; i++) fn[i] = (char) rand();

	for (unsigned int i=0; i<key_str_len; i++) sout << (char) (key_str[i] ^ KEY3);
	print_key(sout, key);
	sout << endl;

	fn += (char*) &key_cmp - (char*) &generate_key;
	for (unsigned int i=0; i<key_cmp_len; i++) fn[i] ^= KEY2;
	if (((key_cmp_t) fn)(&memcmp, key, input_key)) {
		for (unsigned int i=0; i<good_input_len; i++) sout << (char) (good_input[i] ^ KEY3);
	} else {
		for (unsigned int i=0; i<wrong_input_len; i++) sout << (char) (wrong_input[i] ^ KEY3);
	}
	sout << endl;
	for (unsigned int i=0; i<key_cmp_len; i++) fn[i] = (char) rand();
	delete[] input_key;

#ifndef _DEBUG
	Sleep((DWORD) (end_time-time(nullptr)) * 1000); // wait until a minute passes away
#endif

	cout << sout.str();

	return 0;
}
